// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.21.12
// source: booksearch.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "booksearch";

export enum SearchApi {
  GOOGLE_BOOKS = 0,
  OPENLIB = 1,
  UNRECOGNIZED = -1,
}

export function searchApiFromJSON(object: any): SearchApi {
  switch (object) {
    case 0:
    case "GOOGLE_BOOKS":
      return SearchApi.GOOGLE_BOOKS;
    case 1:
    case "OPENLIB":
      return SearchApi.OPENLIB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchApi.UNRECOGNIZED;
  }
}

export function searchApiToJSON(object: SearchApi): string {
  switch (object) {
    case SearchApi.GOOGLE_BOOKS:
      return "GOOGLE_BOOKS";
    case SearchApi.OPENLIB:
      return "OPENLIB";
    case SearchApi.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface BookSearchRequest {
  q: string;
  apiProvider: SearchApi;
  limit: number;
  offset: number;
  tags: string[];
}

export interface BookSearchByIdRequest {
  id: string;
  apiProvider: SearchApi;
}

export interface TransientBook {
  title: string;
  authors: string[];
  description: string;
  publishedAt: string;
  pageCount: number;
  imageLinks: string;
  isbn10: string;
  isbn13: string;
  categories: string[];
  publisher: string;
  googleBookId: string;
}

export interface BookSearchResponse {
  apiProvider: SearchApi;
  totalNumber: number;
  limit: number;
  offset: number;
  result: TransientBook[];
}

export interface BookSearchByIdResponse {
  book: TransientBook | undefined;
}

function createBaseBookSearchRequest(): BookSearchRequest {
  return { q: "", apiProvider: 0, limit: 0, offset: 0, tags: [] };
}

export const BookSearchRequest: MessageFns<BookSearchRequest> = {
  encode(message: BookSearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.q !== "") {
      writer.uint32(10).string(message.q);
    }
    if (message.apiProvider !== 0) {
      writer.uint32(16).int32(message.apiProvider);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).int32(message.offset);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookSearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.q = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.apiProvider = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BookSearchRequest {
    return {
      q: isSet(object.q) ? globalThis.String(object.q) : "",
      apiProvider: isSet(object.apiProvider) ? searchApiFromJSON(object.apiProvider) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BookSearchRequest): unknown {
    const obj: any = {};
    if (message.q !== "") {
      obj.q = message.q;
    }
    if (message.apiProvider !== 0) {
      obj.apiProvider = searchApiToJSON(message.apiProvider);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BookSearchRequest>, I>>(base?: I): BookSearchRequest {
    return BookSearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BookSearchRequest>, I>>(object: I): BookSearchRequest {
    const message = createBaseBookSearchRequest();
    message.q = object.q ?? "";
    message.apiProvider = object.apiProvider ?? 0;
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseBookSearchByIdRequest(): BookSearchByIdRequest {
  return { id: "", apiProvider: 0 };
}

export const BookSearchByIdRequest: MessageFns<BookSearchByIdRequest> = {
  encode(message: BookSearchByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.apiProvider !== 0) {
      writer.uint32(16).int32(message.apiProvider);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookSearchByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookSearchByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.apiProvider = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BookSearchByIdRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      apiProvider: isSet(object.apiProvider) ? searchApiFromJSON(object.apiProvider) : 0,
    };
  },

  toJSON(message: BookSearchByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.apiProvider !== 0) {
      obj.apiProvider = searchApiToJSON(message.apiProvider);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BookSearchByIdRequest>, I>>(base?: I): BookSearchByIdRequest {
    return BookSearchByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BookSearchByIdRequest>, I>>(object: I): BookSearchByIdRequest {
    const message = createBaseBookSearchByIdRequest();
    message.id = object.id ?? "";
    message.apiProvider = object.apiProvider ?? 0;
    return message;
  },
};

function createBaseTransientBook(): TransientBook {
  return {
    title: "",
    authors: [],
    description: "",
    publishedAt: "",
    pageCount: 0,
    imageLinks: "",
    isbn10: "",
    isbn13: "",
    categories: [],
    publisher: "",
    googleBookId: "",
  };
}

export const TransientBook: MessageFns<TransientBook> = {
  encode(message: TransientBook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    for (const v of message.authors) {
      writer.uint32(18).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.publishedAt !== "") {
      writer.uint32(34).string(message.publishedAt);
    }
    if (message.pageCount !== 0) {
      writer.uint32(40).int32(message.pageCount);
    }
    if (message.imageLinks !== "") {
      writer.uint32(50).string(message.imageLinks);
    }
    if (message.isbn10 !== "") {
      writer.uint32(58).string(message.isbn10);
    }
    if (message.isbn13 !== "") {
      writer.uint32(66).string(message.isbn13);
    }
    for (const v of message.categories) {
      writer.uint32(74).string(v!);
    }
    if (message.publisher !== "") {
      writer.uint32(82).string(message.publisher);
    }
    if (message.googleBookId !== "") {
      writer.uint32(90).string(message.googleBookId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransientBook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransientBook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authors.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.publishedAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pageCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.imageLinks = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.isbn10 = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.isbn13 = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.publisher = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.googleBookId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransientBook {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      authors: globalThis.Array.isArray(object?.authors) ? object.authors.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      publishedAt: isSet(object.publishedAt) ? globalThis.String(object.publishedAt) : "",
      pageCount: isSet(object.pageCount) ? globalThis.Number(object.pageCount) : 0,
      imageLinks: isSet(object.imageLinks) ? globalThis.String(object.imageLinks) : "",
      isbn10: isSet(object.isbn10) ? globalThis.String(object.isbn10) : "",
      isbn13: isSet(object.isbn13) ? globalThis.String(object.isbn13) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      publisher: isSet(object.publisher) ? globalThis.String(object.publisher) : "",
      googleBookId: isSet(object.googleBookId) ? globalThis.String(object.googleBookId) : "",
    };
  },

  toJSON(message: TransientBook): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.authors?.length) {
      obj.authors = message.authors;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.publishedAt !== "") {
      obj.publishedAt = message.publishedAt;
    }
    if (message.pageCount !== 0) {
      obj.pageCount = Math.round(message.pageCount);
    }
    if (message.imageLinks !== "") {
      obj.imageLinks = message.imageLinks;
    }
    if (message.isbn10 !== "") {
      obj.isbn10 = message.isbn10;
    }
    if (message.isbn13 !== "") {
      obj.isbn13 = message.isbn13;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.publisher !== "") {
      obj.publisher = message.publisher;
    }
    if (message.googleBookId !== "") {
      obj.googleBookId = message.googleBookId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransientBook>, I>>(base?: I): TransientBook {
    return TransientBook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransientBook>, I>>(object: I): TransientBook {
    const message = createBaseTransientBook();
    message.title = object.title ?? "";
    message.authors = object.authors?.map((e) => e) || [];
    message.description = object.description ?? "";
    message.publishedAt = object.publishedAt ?? "";
    message.pageCount = object.pageCount ?? 0;
    message.imageLinks = object.imageLinks ?? "";
    message.isbn10 = object.isbn10 ?? "";
    message.isbn13 = object.isbn13 ?? "";
    message.categories = object.categories?.map((e) => e) || [];
    message.publisher = object.publisher ?? "";
    message.googleBookId = object.googleBookId ?? "";
    return message;
  },
};

function createBaseBookSearchResponse(): BookSearchResponse {
  return { apiProvider: 0, totalNumber: 0, limit: 0, offset: 0, result: [] };
}

export const BookSearchResponse: MessageFns<BookSearchResponse> = {
  encode(message: BookSearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiProvider !== 0) {
      writer.uint32(8).int32(message.apiProvider);
    }
    if (message.totalNumber !== 0) {
      writer.uint32(16).int32(message.totalNumber);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).int32(message.offset);
    }
    for (const v of message.result) {
      TransientBook.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookSearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.apiProvider = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalNumber = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.result.push(TransientBook.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BookSearchResponse {
    return {
      apiProvider: isSet(object.apiProvider) ? searchApiFromJSON(object.apiProvider) : 0,
      totalNumber: isSet(object.totalNumber) ? globalThis.Number(object.totalNumber) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => TransientBook.fromJSON(e)) : [],
    };
  },

  toJSON(message: BookSearchResponse): unknown {
    const obj: any = {};
    if (message.apiProvider !== 0) {
      obj.apiProvider = searchApiToJSON(message.apiProvider);
    }
    if (message.totalNumber !== 0) {
      obj.totalNumber = Math.round(message.totalNumber);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.result?.length) {
      obj.result = message.result.map((e) => TransientBook.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BookSearchResponse>, I>>(base?: I): BookSearchResponse {
    return BookSearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BookSearchResponse>, I>>(object: I): BookSearchResponse {
    const message = createBaseBookSearchResponse();
    message.apiProvider = object.apiProvider ?? 0;
    message.totalNumber = object.totalNumber ?? 0;
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.result = object.result?.map((e) => TransientBook.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBookSearchByIdResponse(): BookSearchByIdResponse {
  return { book: undefined };
}

export const BookSearchByIdResponse: MessageFns<BookSearchByIdResponse> = {
  encode(message: BookSearchByIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.book !== undefined) {
      TransientBook.encode(message.book, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookSearchByIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookSearchByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.book = TransientBook.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BookSearchByIdResponse {
    return { book: isSet(object.book) ? TransientBook.fromJSON(object.book) : undefined };
  },

  toJSON(message: BookSearchByIdResponse): unknown {
    const obj: any = {};
    if (message.book !== undefined) {
      obj.book = TransientBook.toJSON(message.book);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BookSearchByIdResponse>, I>>(base?: I): BookSearchByIdResponse {
    return BookSearchByIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BookSearchByIdResponse>, I>>(object: I): BookSearchByIdResponse {
    const message = createBaseBookSearchByIdResponse();
    message.book = (object.book !== undefined && object.book !== null)
      ? TransientBook.fromPartial(object.book)
      : undefined;
    return message;
  },
};

export type BookSearchService = typeof BookSearchService;
export const BookSearchService = {
  search: {
    path: "/booksearch.BookSearch/Search",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BookSearchRequest) => Buffer.from(BookSearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BookSearchRequest.decode(value),
    responseSerialize: (value: BookSearchResponse) => Buffer.from(BookSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BookSearchResponse.decode(value),
  },
  searchById: {
    path: "/booksearch.BookSearch/SearchById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BookSearchByIdRequest) => Buffer.from(BookSearchByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BookSearchByIdRequest.decode(value),
    responseSerialize: (value: BookSearchByIdResponse) => Buffer.from(BookSearchByIdResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BookSearchByIdResponse.decode(value),
  },
} as const;

export interface BookSearchServer extends UntypedServiceImplementation {
  search: handleUnaryCall<BookSearchRequest, BookSearchResponse>;
  searchById: handleUnaryCall<BookSearchByIdRequest, BookSearchByIdResponse>;
}

export interface BookSearchClient extends Client {
  search(
    request: BookSearchRequest,
    callback: (error: ServiceError | null, response: BookSearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: BookSearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BookSearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: BookSearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BookSearchResponse) => void,
  ): ClientUnaryCall;
  searchById(
    request: BookSearchByIdRequest,
    callback: (error: ServiceError | null, response: BookSearchByIdResponse) => void,
  ): ClientUnaryCall;
  searchById(
    request: BookSearchByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BookSearchByIdResponse) => void,
  ): ClientUnaryCall;
  searchById(
    request: BookSearchByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BookSearchByIdResponse) => void,
  ): ClientUnaryCall;
}

export const BookSearchClient = makeGenericClientConstructor(BookSearchService, "booksearch.BookSearch") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): BookSearchClient;
  service: typeof BookSearchService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
